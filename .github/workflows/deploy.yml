# =============================================================================
# Blue-Green Lambda Deployment via AWS CodeDeploy
#
# Triggers on every push (or merged PR) to the main branch.
#
# Strategy: LambdaCanary10Percent5Minutes
#   1. Uploads new code and publishes a new Lambda version.
#   2. First run: creates the 'live' alias and updates API Gateway to use it.
#   3. Subsequent runs: CodeDeploy shifts 10% of traffic to the new version
#      for 5 minutes, monitoring the LambdaErrorAlarm. If no alarm fires,
#      traffic shifts to 100%. If the alarm fires, CodeDeploy auto-rolls back.
#
# Prerequisites (one-time setup):
#   1. Deploy infra/github-oidc.yml to create the OIDC provider and deploy role.
#   2. Add the role ARN as the AWS_DEPLOY_ROLE_ARN secret in GitHub:
#      Settings → Secrets and variables → Actions → New repository secret.
#   3. Deploy infra/services/api.yml (via deploy.sh) to create the CodeDeploy
#      application and deployment group added in this branch.
# =============================================================================

name: Deploy to Lambda (Blue-Green)

on:
  push:
    branches:
      - main

env:
  AWS_REGION: us-east-2
  PROJECT_NAME: pbxscribe-api-backend
  ENVIRONMENT: dev
  ALIAS_NAME: live

jobs:
  deploy:
    name: Blue-Green Lambda Deploy
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # Required for OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: src/api/package-lock.json

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install production dependencies
        working-directory: src/api
        run: npm ci --omit=dev --silent

      - name: Package Lambda
        run: |
          rm -rf .build function.zip
          cp -r src/api .build
          rm -rf .build/tests
          (cd .build && zip -r ../function.zip . -x "*.git*" > /dev/null)
          rm -rf .build
          echo "Package size: $(du -sh function.zip | cut -f1)"

      - name: Upload Lambda code and publish version
        run: |
          FUNCTION_NAME="${PROJECT_NAME}-${ENVIRONMENT}-api"

          echo "Uploading code to Lambda..."
          aws lambda update-function-code \
            --function-name "$FUNCTION_NAME" \
            --zip-file fileb://function.zip \
            --no-cli-pager > /dev/null

          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$FUNCTION_NAME"

          echo "Publishing new version..."
          NEW_VERSION=$(aws lambda publish-version \
            --function-name "$FUNCTION_NAME" \
            --description "Deployed from ${{ github.sha }} by ${{ github.actor }}" \
            --query 'Version' \
            --output text \
            --no-cli-pager)

          echo "FUNCTION_NAME=$FUNCTION_NAME" >> "$GITHUB_ENV"
          echo "NEW_VERSION=$NEW_VERSION"      >> "$GITHUB_ENV"
          echo "Published version $NEW_VERSION"

      - name: Blue-Green Deploy
        run: |
          CODEDEPLOY_APP="${PROJECT_NAME}-${ENVIRONMENT}-api"
          CODEDEPLOY_GROUP="${PROJECT_NAME}-${ENVIRONMENT}-api-dg"
          STACK_NAME="${PROJECT_NAME}-${ENVIRONMENT}-api"

          # ── Check whether the 'live' alias already exists ──────────────────
          CURRENT_VERSION=$(aws lambda get-alias \
            --function-name "$FUNCTION_NAME" \
            --name "$ALIAS_NAME" \
            --query 'FunctionVersion' \
            --output text \
            --no-cli-pager 2>/dev/null || echo "")

          # ── FIRST DEPLOYMENT: bootstrap the alias ──────────────────────────
          if [ -z "$CURRENT_VERSION" ]; then
            echo "=== First deployment: initializing '$ALIAS_NAME' alias ==="

            aws lambda create-alias \
              --function-name "$FUNCTION_NAME" \
              --name "$ALIAS_NAME" \
              --function-version "$NEW_VERSION" \
              --description "Production live alias (blue-green)" \
              --no-cli-pager > /dev/null

            ACCOUNT_ID=$(aws sts get-caller-identity \
              --query Account --output text --no-cli-pager)

            FUNCTION_ARN=$(aws lambda get-function \
              --function-name "$FUNCTION_NAME" \
              --query 'Configuration.FunctionArn' \
              --output text --no-cli-pager)

            ALIAS_ARN="${FUNCTION_ARN}:${ALIAS_NAME}"

            # Update API Gateway integration to invoke through the alias
            API_ID=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query "Stacks[0].Outputs[?OutputKey=='HttpApiId'].OutputValue" \
              --output text --no-cli-pager)

            INTEGRATION_ID=$(aws apigatewayv2 get-integrations \
              --api-id "$API_ID" \
              --query 'Items[0].IntegrationId' \
              --output text --no-cli-pager)

            aws apigatewayv2 update-integration \
              --api-id "$API_ID" \
              --integration-id "$INTEGRATION_ID" \
              --integration-uri "$ALIAS_ARN" \
              --no-cli-pager > /dev/null

            # Grant API Gateway permission to invoke the alias
            aws lambda add-permission \
              --function-name "${FUNCTION_NAME}:${ALIAS_NAME}" \
              --statement-id "AllowAPIGatewayInvoke-${ALIAS_NAME}" \
              --action "lambda:InvokeFunction" \
              --principal "apigateway.amazonaws.com" \
              --source-arn "arn:aws:execute-api:${AWS_REGION}:${ACCOUNT_ID}:${API_ID}/*" \
              --no-cli-pager > /dev/null

            echo "Alias '$ALIAS_NAME' created → version $NEW_VERSION"
            echo "API Gateway now routes traffic through the '$ALIAS_NAME' alias"
            echo "DEPLOYMENT_ID=initial" >> "$GITHUB_ENV"

          # ── SUBSEQUENT DEPLOYMENTS: CodeDeploy canary traffic shift ────────
          else
            echo "Current alias version: $CURRENT_VERSION → New version: $NEW_VERSION"

            if [ "$CURRENT_VERSION" = "$NEW_VERSION" ]; then
              echo "No version change detected — skipping deployment"
              echo "DEPLOYMENT_ID=skipped" >> "$GITHUB_ENV"
              exit 0
            fi

            echo "=== Blue-green deploy: $CURRENT_VERSION → $NEW_VERSION ==="
            echo "Traffic: 10% to new version for 5 min, then 100% if no alarms"

            # Build AppSpec JSON for CodeDeploy
            APPSPEC=$(jq -n \
              --arg name    "$FUNCTION_NAME" \
              --arg alias   "$ALIAS_NAME" \
              --arg current "$CURRENT_VERSION" \
              --arg target  "$NEW_VERSION" \
              '{
                "version": 0.0,
                "Resources": [{
                  "ApiLambdaFunction": {
                    "Type": "AWS::Lambda::Function",
                    "Properties": {
                      "Name":           $name,
                      "Alias":          $alias,
                      "CurrentVersion": $current,
                      "TargetVersion":  $target
                    }
                  }
                }]
              }')

            # Wrap AppSpec in the CodeDeploy revision envelope
            REVISION=$(echo "$APPSPEC" | jq '{
              "revisionType": "AppSpecContent",
              "appSpecContent": {
                "content": (. | tojson)
              }
            }')

            DEPLOYMENT_ID=$(aws deploy create-deployment \
              --application-name "$CODEDEPLOY_APP" \
              --deployment-group-name "$CODEDEPLOY_GROUP" \
              --revision "$REVISION" \
              --description "Commit ${{ github.sha }} by ${{ github.actor }}" \
              --query 'deploymentId' \
              --output text \
              --no-cli-pager)

            echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> "$GITHUB_ENV"
            echo "CodeDeploy deployment: $DEPLOYMENT_ID"
          fi

      - name: Wait for CodeDeploy to complete
        # Only runs for real CodeDeploy deployments (not first-run or skipped)
        if: ${{ !contains(env.DEPLOYMENT_ID, 'initial') && !contains(env.DEPLOYMENT_ID, 'skipped') }}
        run: |
          echo "Waiting for $DEPLOYMENT_ID..."
          aws deploy wait deployment-successful \
            --deployment-id "$DEPLOYMENT_ID" \
            --no-cli-pager
          echo "Deployment successful!"

      - name: Verify active version
        run: |
          FINAL_VERSION=$(aws lambda get-alias \
            --function-name "$FUNCTION_NAME" \
            --name "$ALIAS_NAME" \
            --query 'FunctionVersion' \
            --output text \
            --no-cli-pager 2>/dev/null || echo "N/A")
          echo "Alias '$ALIAS_NAME' is now serving version $FINAL_VERSION"

      - name: Report CodeDeploy failure details
        if: failure()
        run: |
          if [[ "${DEPLOYMENT_ID:-}" == d-* ]]; then
            echo "CodeDeploy deployment status:"
            aws deploy get-deployment \
              --deployment-id "$DEPLOYMENT_ID" \
              --query 'deploymentInfo.{Status:status,ErrorInfo:errorInformation}' \
              --output json \
              --no-cli-pager || true
            echo ""
            echo "CodeDeploy may have auto-rolled back to version $CURRENT_VERSION."
          fi
