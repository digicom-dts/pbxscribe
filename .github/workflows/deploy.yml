# =============================================================================
# Blue-Green Lambda Deployment via AWS CodeDeploy
#
# BRANCH → ENVIRONMENT MAPPING
# ┌──────────────┬─────────────┬───────────────────────────────────────────┐
# │ Branch       │ Environment │ Notes                                     │
# ├──────────────┼─────────────┼───────────────────────────────────────────┤
# │ develop      │ dev         │ Auto-deploys on every push                │
# │ main         │ prod        │ Requires approval (configure in GitHub)   │
# │ staging      │ staging     │ Auto-deploys on every push                │
# └──────────────┴─────────────┴───────────────────────────────────────────┘
# To change the mapping, edit the 'Map branch → environment' step below.
# To use the same branch for all envs, just keep one entry in the mapping.
#
# ISOLATION GUARANTEE
# Each environment has its own AWS_DEPLOY_ROLE_ARN secret stored at the
# GitHub Environment level. The matching IAM role (created by setup-cicd.sh)
# can only be assumed when the workflow is running inside that named GitHub
# Environment. A dev role cannot touch prod infrastructure, and vice versa.
#
# STRATEGY: LambdaCanary10Percent5Minutes
#   Routes 10% of traffic to the new Lambda version for 5 minutes.
#   Auto-rolls back if the LambdaErrorAlarm fires (≥3 errors / 60s).
#
# PREREQUISITES (run setup-cicd.sh once per environment):
#   ./setup-cicd.sh dev   — sets up dev
#   ./setup-cicd.sh prod  — sets up prod
# =============================================================================

name: Deploy to Lambda (Blue-Green)

on:
  push:
    branches: ['**']  # All branches — unmapped ones exit early in resolve-environment

env:
  AWS_REGION: us-east-2
  PROJECT_NAME: pbxscribe-api-backend
  ALIAS_NAME: live

jobs:
  # ── Resolve which environment this branch deploys to ──────────────────────
  resolve-environment:
    name: Resolve Environment
    runs-on: ubuntu-latest
    permissions:
      contents: read   # default token — needed to call GitHub API below
    outputs:
      environment: ${{ steps.map.outputs.environment }}
    steps:
      - name: Map branch → environment
        id: map
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          BRANCH="${{ github.ref_name }}"
          ENV=""

          # Priority 1: DEPLOY_BRANCH variable on each GitHub Environment.
          # Set via setup-cicd.sh or directly in:
          #   GitHub → Settings → Environments → <env> → Variables → DEPLOY_BRANCH
          for candidate in dev staging prod; do
            CONFIGURED=$(gh api \
              "repos/${{ github.repository }}/environments/${candidate}/variables/DEPLOY_BRANCH" \
              --jq '.value' 2>/dev/null || echo "")
            if [ -n "$CONFIGURED" ] && [ "$CONFIGURED" = "$BRANCH" ]; then
              ENV="$candidate"
              break
            fi
          done

          # Priority 2: Inline map — fallback when environment variables are not set.
          # Kept in sync by setup-cicd.sh; can also be edited manually.
          if [ -z "$ENV" ]; then
            case "$BRANCH" in
              # BEGIN_BRANCH_MAP
              main) ENV="dev" ;;
              staging) ENV="staging" ;;
              # END_BRANCH_MAP
              *) ENV="" ;;
            esac
          fi

          if [ -z "$ENV" ]; then
            echo "Branch '$BRANCH' has no environment mapping — skipping."
            exit 0
          fi

          echo "environment=$ENV" >> "$GITHUB_OUTPUT"
          echo "Branch '$BRANCH' → environment '$ENV'"

  # ── Blue-green Lambda deployment ──────────────────────────────────────────
  deploy:
    name: Deploy → ${{ needs.resolve-environment.outputs.environment }}
    needs: resolve-environment
    runs-on: ubuntu-latest

    # GitHub Environment — provides environment-scoped AWS_DEPLOY_ROLE_ARN
    # secret and optional approval gates (configure in repo Settings).
    # The matching IAM role trust policy is locked to this environment name,
    # so a dev role cannot be assumed when deploying to prod, and vice versa.
    environment: ${{ needs.resolve-environment.outputs.environment }}

    env:
      ENVIRONMENT: ${{ needs.resolve-environment.outputs.environment }}

    permissions:
      id-token: write  # Required for OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: src/api/package-lock.json

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install production dependencies
        working-directory: src/api
        run: npm ci --omit=dev --silent

      - name: Package Lambda
        run: |
          rm -rf .build function.zip
          cp -r src/api .build
          rm -rf .build/tests
          (cd .build && zip -r ../function.zip . -x "*.git*" > /dev/null)
          rm -rf .build
          echo "Package size: $(du -sh function.zip | cut -f1)"

      - name: Upload Lambda code and publish version
        run: |
          FUNCTION_NAME="${PROJECT_NAME}-${ENVIRONMENT}-api"

          echo "Uploading code to Lambda..."
          aws lambda update-function-code \
            --function-name "$FUNCTION_NAME" \
            --zip-file fileb://function.zip \
            --no-cli-pager > /dev/null

          echo "Waiting for update to complete..."
          aws lambda wait function-updated \
            --function-name "$FUNCTION_NAME"

          echo "Publishing new version..."
          NEW_VERSION=$(aws lambda publish-version \
            --function-name "$FUNCTION_NAME" \
            --description "Deployed from ${{ github.sha }} by ${{ github.actor }}" \
            --query 'Version' \
            --output text \
            --no-cli-pager)

          echo "FUNCTION_NAME=$FUNCTION_NAME" >> "$GITHUB_ENV"
          echo "NEW_VERSION=$NEW_VERSION"      >> "$GITHUB_ENV"
          echo "Published version $NEW_VERSION"

      - name: Blue-Green Deploy
        run: |
          CODEDEPLOY_APP="${PROJECT_NAME}-${ENVIRONMENT}-api"
          CODEDEPLOY_GROUP="${PROJECT_NAME}-${ENVIRONMENT}-api-dg"
          STACK_NAME="${PROJECT_NAME}-${ENVIRONMENT}-api"

          # ── Check whether the 'live' alias already exists ──────────────────
          CURRENT_VERSION=$(aws lambda get-alias \
            --function-name "$FUNCTION_NAME" \
            --name "$ALIAS_NAME" \
            --query 'FunctionVersion' \
            --output text \
            --no-cli-pager 2>/dev/null || echo "")

          # ── FIRST DEPLOYMENT: bootstrap the alias ──────────────────────────
          if [ -z "$CURRENT_VERSION" ]; then
            echo "=== First deployment: initializing '$ALIAS_NAME' alias ==="

            aws lambda create-alias \
              --function-name "$FUNCTION_NAME" \
              --name "$ALIAS_NAME" \
              --function-version "$NEW_VERSION" \
              --description "Live alias (blue-green, $ENVIRONMENT)" \
              --no-cli-pager > /dev/null

            ACCOUNT_ID=$(aws sts get-caller-identity \
              --query Account --output text --no-cli-pager)

            FUNCTION_ARN=$(aws lambda get-function \
              --function-name "$FUNCTION_NAME" \
              --query 'Configuration.FunctionArn' \
              --output text --no-cli-pager)

            ALIAS_ARN="${FUNCTION_ARN}:${ALIAS_NAME}"

            # Update API Gateway integration to invoke through the alias
            API_ID=$(aws cloudformation describe-stacks \
              --stack-name "$STACK_NAME" \
              --query "Stacks[0].Outputs[?OutputKey=='HttpApiId'].OutputValue" \
              --output text --no-cli-pager)

            INTEGRATION_ID=$(aws apigatewayv2 get-integrations \
              --api-id "$API_ID" \
              --query 'Items[0].IntegrationId' \
              --output text --no-cli-pager)

            aws apigatewayv2 update-integration \
              --api-id "$API_ID" \
              --integration-id "$INTEGRATION_ID" \
              --integration-uri "$ALIAS_ARN" \
              --no-cli-pager > /dev/null

            # Grant API Gateway permission to invoke the alias
            aws lambda add-permission \
              --function-name "${FUNCTION_NAME}:${ALIAS_NAME}" \
              --statement-id "AllowAPIGatewayInvoke-${ALIAS_NAME}" \
              --action "lambda:InvokeFunction" \
              --principal "apigateway.amazonaws.com" \
              --source-arn "arn:aws:execute-api:${AWS_REGION}:${ACCOUNT_ID}:${API_ID}/*" \
              --no-cli-pager > /dev/null

            echo "Alias '$ALIAS_NAME' created → version $NEW_VERSION"
            echo "API Gateway now routes traffic through the '$ALIAS_NAME' alias"
            echo "DEPLOYMENT_ID=initial" >> "$GITHUB_ENV"

          # ── SUBSEQUENT DEPLOYMENTS: CodeDeploy canary traffic shift ────────
          else
            echo "Current alias version: $CURRENT_VERSION → New version: $NEW_VERSION"

            if [ "$CURRENT_VERSION" = "$NEW_VERSION" ]; then
              echo "No version change detected — skipping deployment"
              echo "DEPLOYMENT_ID=skipped" >> "$GITHUB_ENV"
              exit 0
            fi

            echo "=== Blue-green deploy ($ENVIRONMENT): $CURRENT_VERSION → $NEW_VERSION ==="
            echo "Traffic: 10% to new version for 5 min, then 100% if no alarms"

            # Build AppSpec JSON for CodeDeploy
            APPSPEC=$(jq -n \
              --arg name    "$FUNCTION_NAME" \
              --arg alias   "$ALIAS_NAME" \
              --arg current "$CURRENT_VERSION" \
              --arg target  "$NEW_VERSION" \
              '{
                "version": 0.0,
                "Resources": [{
                  "ApiLambdaFunction": {
                    "Type": "AWS::Lambda::Function",
                    "Properties": {
                      "Name":           $name,
                      "Alias":          $alias,
                      "CurrentVersion": $current,
                      "TargetVersion":  $target
                    }
                  }
                }]
              }')

            # Wrap AppSpec in the CodeDeploy revision envelope
            REVISION=$(echo "$APPSPEC" | jq '{
              "revisionType": "AppSpecContent",
              "appSpecContent": { "content": (. | tojson) }
            }')

            DEPLOYMENT_ID=$(aws deploy create-deployment \
              --application-name "$CODEDEPLOY_APP" \
              --deployment-group-name "$CODEDEPLOY_GROUP" \
              --revision "$REVISION" \
              --description "Commit ${{ github.sha }} by ${{ github.actor }}" \
              --query 'deploymentId' \
              --output text \
              --no-cli-pager)

            echo "DEPLOYMENT_ID=$DEPLOYMENT_ID" >> "$GITHUB_ENV"
            echo "CodeDeploy deployment: $DEPLOYMENT_ID"
          fi

      - name: Wait for CodeDeploy to complete
        if: ${{ !contains(env.DEPLOYMENT_ID, 'initial') && !contains(env.DEPLOYMENT_ID, 'skipped') }}
        run: |
          echo "Waiting for $DEPLOYMENT_ID..."
          aws deploy wait deployment-successful \
            --deployment-id "$DEPLOYMENT_ID" \
            --no-cli-pager
          echo "Deployment successful!"

      - name: Verify active version
        run: |
          FINAL_VERSION=$(aws lambda get-alias \
            --function-name "$FUNCTION_NAME" \
            --name "$ALIAS_NAME" \
            --query 'FunctionVersion' \
            --output text \
            --no-cli-pager 2>/dev/null || echo "N/A")
          echo "[$ENVIRONMENT] Alias '$ALIAS_NAME' is now serving version $FINAL_VERSION"

      - name: Report CodeDeploy failure details
        if: failure()
        run: |
          if [[ "${DEPLOYMENT_ID:-}" == d-* ]]; then
            echo "CodeDeploy deployment status:"
            aws deploy get-deployment \
              --deployment-id "$DEPLOYMENT_ID" \
              --query 'deploymentInfo.{Status:status,ErrorInfo:errorInformation}' \
              --output json \
              --no-cli-pager || true
            echo ""
            echo "CodeDeploy may have auto-rolled back to version $CURRENT_VERSION."
          fi
